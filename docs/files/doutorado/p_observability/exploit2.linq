<Query Kind="Statements">
  <Reference>&lt;RuntimeDirectory&gt;\System.ValueTuple.dll</Reference>
  <NuGetReference>UltraDES</NuGetReference>
  <Namespace>UltraDES</Namespace>
</Query>

var s = Enumerable.Range(0, 20).Select(i => new State($"s{i}", i == 0 ? Marking.Marked : Marking.Unmarked)).ToArray();



Event g = new Event("g", Controllability.Controllable);
Event d = new Event("d", Controllability.Controllable);
Event a = new Event("a", Controllability.Uncontrollable);
Event b = new Event("b", Controllability.Uncontrollable);
Event c = new Event("c", Controllability.Uncontrollable);
Event z = new Event("z", Controllability.Controllable);
Event f = new Event("f", Controllability.Uncontrollable);
Event e = new Event("e", Controllability.Uncontrollable);
Event y = new Event("y", Controllability.Uncontrollable);

Event a1 = new Event("a1", Controllability.Controllable);
Event b1 = new Event("b1", Controllability.Uncontrollable);
Event a2 = new Event("a2", Controllability.Controllable);
Event b2 = new Event("b2", Controllability.Uncontrollable);



// Creating Automata

var M1 = new DeterministicFiniteAutomaton(new[]
  {
	new Transition(s[0], a1, s[1]),
	new Transition(s[1], b1, s[0])
  }, s[0], "M1");

var M2 = new DeterministicFiniteAutomaton(new[]
  {
	new Transition(s[0], a2, s[1]),
	new Transition(s[1], b2, s[0])
  }, s[0], "M2");

var E1 = new DeterministicFiniteAutomaton(new[]
  {
	new Transition(s[0], b1, s[1]),
	new Transition(s[1], a2, s[0])
  }, s[0], "E1");
  
var GM = M1.ParallelCompositionWith(M2);
var K2 = GM.ParallelCompositionWith(E1).Trim;


var G = new DeterministicFiniteAutomaton(new[]
  {
	new Transition(s[0], g, s[0]),
	new Transition(s[0], a, s[1]),
	new Transition(s[1], a, s[6]),
	new Transition(s[0], d, s[4]),
	new Transition(s[6], b, s[2]),
	new Transition(s[2], c, s[3]),
	new Transition(s[3], d, s[0]),
	new Transition(s[3], g, s[5])
  }, s[0], "G");

var G3 = new DeterministicFiniteAutomaton(new[]
{
	new Transition(s[0], a, s[1]),
	new Transition(s[1], b, s[2]),
	new Transition(s[2], c, s[3]),
	new Transition(s[3], e, s[4]),
	new Transition(s[4], f, s[5])
  }, s[0], "G3");

var K = new DeterministicFiniteAutomaton(new[]
{
	new Transition(s[0], g, s[0]),
	new Transition(s[0], a, s[1]),
	new Transition(s[1], a, s[6]),
	new Transition(s[6], b, s[2]),
	new Transition(s[2], c, s[3]),
	new Transition(s[3], d, s[0])
  }, s[0], "K");

var G2 = new DeterministicFiniteAutomaton(new[]
{
	new Transition(s[0], a, s[1]),
	new Transition(s[0], d, s[8]),
	new Transition(s[0], y, s[4]),
	new Transition(s[1], b, s[2]),
	new Transition(s[2], c, s[3]),
	new Transition(s[3], g, s[7]),
	new Transition(s[3], d, s[0]),
	new Transition(s[4], d, s[9]),
	new Transition(s[4], f, s[5]),
	new Transition(s[5], e, s[6]),
	new Transition(s[6], z, s[10]),
	new Transition(s[6], d, s[0]),


  }, s[0], "G2");


//K.ShowAutomaton();
var S = DeterministicFiniteAutomaton.MonolithicSupervisor(new[] { G }, new[] { K});
//S.ShowAutomaton("S");
//var dis = S.DisabledEvents(new[] { G });

Dictionary<AbstractState, List<Transition>> transitions_by_origin = G2.Transitions.GroupBy(t => t.Origin)
																	.ToDictionary(xi => xi.Key, xi => xi.ToList());

Dictionary<AbstractState, List<Transition>> transitions_by_destination = G2.Transitions.GroupBy(t => t.Destination)
																	.ToDictionary(xi => xi.Key, xi => xi.ToList());

List<Event> v1 = new[] { g }.ToList();
List<Event> v2 = new[] { a, b, c, e, f}.ToList();
List<Event> v3 = new[] { b1}.ToList();

//var P = check_Pobservability(G, K, v2);
//var P2 = check_Pobservability(G3, K2, v3);
var mstates =  build_estimator(G3, v2);
var d2 = neighbor_states2(G, s[6], 2, v2);
var r= 0 ;

//var po = possible_states(transitions_by_origin, ms, s[1]);

Boolean check_Pobservability(DeterministicFiniteAutomaton H, DeterministicFiniteAutomaton desired_language, List<Event> vulnerable_events){

	
	var sup = DeterministicFiniteAutomaton.MonolithicSupervisor(new[] { H }, new[] { desired_language }).SimplifyStatesName();
	//sup.ShowAutomaton("S");
	var macrostates = build_estimator(sup, vulnerable_events);
	
	print_macrostates(macrostates);
	
	var dis = sup.DisabledEvents(new[] {H});
	
	List<(AbstractState, AbstractState)> CC = new List<(AbstractState, AbstractState)> ();
	Console.WriteLine("Control Consistent states: ");
	foreach(var ms in macrostates)
	{
		if(ms.Count()>1)
		{
			/*
			foreach(var r in CC){
				if (ms.Contains(r.Item1) && ms.Contains(r.Item2)){
					return false;
				}
			}*/			
			
			foreach (var st in ms)
			{
				foreach (var st2 in ms.Except(new[] { st }))
				{
					if(CC.Contains((st, st2)) || CC.Contains((st2, st))) { 
						continue;
					}
					else
					{
						if (feasible_event(sup, st).Intersect(dis[st2]).Count() > 0)
						{
							//R.Add((st, st2));
							Console.WriteLine("\n States " + st.ToString() + " and " + st2.ToString() + " are not control consistent");
							return false;
						}
						else
						{
							Console.WriteLine(st.ToString() + ", " + st2.ToString());
							CC.Add((st, st2));
						}
					}
				}
			}

		}
	}
	Console.WriteLine("\nK is P-observable");
	return true;
	
}


void print_macrostates(List<List<AbstractState>> macro_states){

	Console.WriteLine("List of macro states:");
	foreach(var st in macro_states){
		Console.Write("(");
		foreach(var q in st){
			Console.Write(q.ToString() + " ");
		}
		Console.WriteLine(")");
	}
}


List<List<AbstractState>> build_estimator(DeterministicFiniteAutomaton H, List<Event> vulnerable_events){

	List<List<AbstractState>> macro_states = new List<List<AbstractState>>();
	List<AbstractState> states = new List<AbstractState>();
	
	
	foreach(var st in H.States)
	{
		states = possible_states1(H, st, vulnerable_events);
		macro_states.Add(states);
		
	}
	return macro_states;
}

List<AbstractEvent> feasible_event(DeterministicFiniteAutomaton H, AbstractState state){
	
	List<AbstractEvent> events = new List<AbstractEvent>();
	foreach(var t in H.Transitions.Where(x => (x.Origin == state))){
		events.Add(t.Trigger);
	}
	return events;
}



List<AbstractState> possible_states1(DeterministicFiniteAutomaton H, AbstractState state, List<Event> vulnerable_events)
{
	List<AbstractState> states = new List<AbstractState>();
	
	states.AddRange(neighbor_states2(H, state, 2, vulnerable_events));
	states.Add(state);
	
	return states;
	
}


List<AbstractState> neighbor_states2(DeterministicFiniteAutomaton H, AbstractState state, int n, List<Event> vulnerable_events)
{

	var radius = 1;
	List<Event> manipulated_events = new List<Event>();

	List<AbstractState> visited_states = new List<AbstractState>();
	List<AbstractState> frontier_after = new List<AbstractState>();
	List<AbstractState> frontier_after_aux = new List<AbstractState>();
	List<AbstractState> frontier_before = new List<AbstractState>();
	List<AbstractState> frontier_before_aux = new List<AbstractState>();
	

	frontier_after.Add(state);
	frontier_before.Add(state);
	
	while (radius <= n)
	{
		foreach (var s2 in frontier_after) 
		{
			
			foreach (var t in H.Transitions.Where(x => (x.Origin == s2)))
			{
				var ev = t.Trigger;
				if (vulnerable_events.Contains(ev))
				{
					visited_states.Add(t.Destination);

					var ns = t.Destination;
					var nt = H.Transitions.Where(x => (x.Origin == ns) && (x.Trigger == ev));
					while (nt.Count() == 1 && !(visited_states.Contains(nt.ElementAt(0).Destination)))
					{
						ns = nt.ElementAt(0).Destination;
						nt = H.Transitions.Where(x => (x.Origin == ns) && (x.Trigger == ev));
						visited_states.Add(ns);
					}
					frontier_after_aux.Add(ns);
				}

			}
		}
	
		foreach (var s2 in frontier_before)
		{
			foreach (var t in H.Transitions.Where(x => (x.Destination == s2)))
			{
				var ev = t.Trigger;
				if (vulnerable_events.Contains(t.Trigger) && !(visited_states.Contains(t.Origin)))
				{
					visited_states.Add(t.Origin);

					var ns = t.Origin;
					var nt = H.Transitions.Where(x => (x.Destination == ns) && (x.Trigger == ev));
					while (nt.Count() == 1 && !(visited_states.Contains(nt.ElementAt(0).Origin)))
					{
						ns = nt.ElementAt(0).Origin;
						nt = H.Transitions.Where(x => (x.Destination == ns) && (x.Trigger == ev));
						visited_states.Add(ns);
					}
					frontier_before_aux.Add(ns);
				}
			}
		}
		frontier_after.Clear();
		frontier_before.Clear();
		frontier_after.AddRange(frontier_after_aux);
		frontier_before.AddRange(frontier_before_aux);
		frontier_after_aux.Clear();
		frontier_before_aux.Clear();
	
	
		radius++;
	}
	return visited_states;
}
List<AbstractState> neighbor_states(DeterministicFiniteAutomaton H, AbstractState state, List<Event> vulnerable_events)
{

	List<AbstractState> states = new List<AbstractState>();
	List<AbstractState> visited_states = new List<AbstractState>();



	foreach (var t in H.Transitions.Where(x => (x.Origin == state)))
	{
		var ev = t.Trigger;
		if (vulnerable_events.Contains(ev))
		{
			states.Add(t.Destination);
			visited_states.Add(t.Destination);

			var ns = t.Destination;
			var nt = H.Transitions.Where(x => (x.Origin == ns) && (x.Trigger == ev));
			while (nt.Count() == 1 && !(visited_states.Contains(nt.ElementAt(0).Destination)))
			{
				ns = nt.ElementAt(0).Destination;
				nt = H.Transitions.Where(x => (x.Origin == ns) && (x.Trigger == ev));
				states.Add(ns);
				visited_states.Add(ns);
			}
		}
		
	}
	foreach (var t in H.Transitions.Where(x => (x.Destination == state)))
	{
		var ev = t.Trigger;
		if (vulnerable_events.Contains(t.Trigger) && !(visited_states.Contains(t.Origin)))
		{
			states.Add(t.Origin);
			visited_states.Add(t.Origin);

			var ns = t.Origin;
			var nt = H.Transitions.Where(x => (x.Destination == ns) && (x.Trigger == ev));
			while (nt.Count() == 1 && !(visited_states.Contains(nt.ElementAt(0).Origin)))
			{
				ns = nt.ElementAt(0).Origin;
				nt = H.Transitions.Where(x => (x.Destination == ns) && (x.Trigger == ev));
				states.Add(ns);
				visited_states.Add(ns);
			}
		}
	}

	return states;

}



//IEnumerable<IGrouping<AbstractState, Transition>> query = from t in G.Transitions
//										 		  group t by t.Origin;

//G.ShowAutomaton();