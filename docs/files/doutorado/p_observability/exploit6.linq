<Query Kind="Statements">
  <Reference>&lt;RuntimeDirectory&gt;\System.ValueTuple.dll</Reference>
  <NuGetReference>UltraDES</NuGetReference>
  <Namespace>UltraDES</Namespace>
</Query>

var s = Enumerable.Range(0, 20).Select(ii => new State($"s{ii}", ii == 0 ? Marking.Marked : Marking.Unmarked)).ToArray();



Event g = new Event("g", Controllability.Uncontrollable);
Event d = new Event("d", Controllability.Uncontrollable);
Event a = new Event("a", Controllability.Uncontrollable);
Event b = new Event("b", Controllability.Uncontrollable);
Event c = new Event("c", Controllability.Uncontrollable);
Event h = new Event("h", Controllability.Uncontrollable);
Event f = new Event("f", Controllability.Uncontrollable);
Event e = new Event("e", Controllability.Uncontrollable);
Event i = new Event("i", Controllability.Uncontrollable);
Event j = new Event("j", Controllability.Uncontrollable);
Event k = new Event("k", Controllability.Uncontrollable);
Event l = new Event("l", Controllability.Uncontrollable);
Event m = new Event("m", Controllability.Uncontrollable);
Event y = new Event("y", Controllability.Controllable);
Event x = new Event("x", Controllability.Controllable);


var G9 = new DeterministicFiniteAutomaton(new[]
{
	new Transition(s[0], a, s[1]),
	new Transition(s[1], b, s[2]),
	new Transition(s[2], c, s[3]),
	new Transition(s[3], f, s[2]),
	new Transition(s[2], e, s[1]),
	new Transition(s[1], d, s[0]),
	new Transition(s[0], g, s[2]),
	new Transition(s[1], h, s[3]),
	new Transition(s[3], i, s[1]),
	new Transition(s[2], j, s[0]),
	new Transition(s[0], k, s[3]),
	new Transition(s[3], l, s[0]),
	new Transition(s[0], x, s[4]),
	new Transition(s[0], y, s[0]),
	new Transition(s[3], y, s[5]),
	new Transition(s[3], x, s[0]),

  }, s[0], "G9");
  
var G10 = new DeterministicFiniteAutomaton(new[]
{
	new Transition(s[0], a, s[1]),
	new Transition(s[1], b, s[2]),
	new Transition(s[2], d, s[3]),
	new Transition(s[3], f, s[4]),
	new Transition(s[4], h, s[5]),
	new Transition(s[1], c, s[6]),
	new Transition(s[6], e, s[7]),
	new Transition(s[7], g, s[5])

  }, s[0], "G10");

var K10 = new DeterministicFiniteAutomaton(new[]
{
	new Transition(s[0], a, s[1]),
	new Transition(s[1], b, s[2]),
	new Transition(s[2], c, s[3]),
	new Transition(s[3], d, s[4]),
	new Transition(s[4], e, s[5]),
	new Transition(s[5], f, s[6]),
	new Transition(s[0], g, s[3]),
	new Transition(s[2], h, s[5]),
	new Transition(s[4], i, s[1]),
	new Transition(s[0], y, s[0]),
	new Transition(s[6], x, s[0]),

  }, s[0], "K7");



//pequenaFabrica(out var plants, out var specs, out var evs);
//DeterministicFiniteAutomaton.FromWmodFile(@"D:\Dropbox\Doutorado\Plantas linqpad\tank_process.wmod", out var plants, out var specs);
//var G9 = DeterministicFiniteAutomaton.ParallelComposition(plants);
//var K9 = DeterministicFiniteAutomaton.ParallelComposition(specs);
//List<Event> v2 = new[] {b, c, d, e, g, h }.ToList();
List<Event> v2 = new[] {g, c}.ToList(); // bd


//var proj_G9 = G9.Projection(v2.ToList());
//proj_G9.ShowAutomaton("G9");

//var S = DeterministicFiniteAutomaton.MonolithicSupervisor(plants.ToArray(), specs.ToArray()).SimplifyStatesName();
List<List<AbstractState>> Pi = new List<List<AbstractState>>();


//var heads = funcao3(G9, v2, out Pi);
Console.WriteLine();
var Pi2 = funcao2(G9, v2);

Dictionary<AbstractState, AbstractState> funcao3(DeterministicFiniteAutomaton H, List<Event> alpha, out List<List<AbstractState>> pi)
{
	List<Transition> new_transitions = new List<Transition>();
	foreach (var tr in H.Transitions)
	{
		if (alpha.Contains(tr.Trigger))
		{
			new_transitions.Add(tr);
		}
	}
	var nG = new DeterministicFiniteAutomaton(new_transitions, H.InitialState, "newG");
	
	// os fake events são necessários para que exista alguma transição com os estados que ficam isolados.
	Event fake = new Event("fa", Controllability.Uncontrollable);
	foreach (var st in H.States)
	{
		new_transitions.Add(new Transition(st, fake, st));
	}

	var nG2 = new DeterministicFiniteAutomaton(new_transitions, H.InitialState, "newG2");

	//nG.ShowAutomaton("nG");
	//nG2.ShowAutomaton("nG2");

	Dictionary<AbstractState, List<Transition>> transitions_by_destination = nG.Transitions.Where(t=> t.Trigger != fake).GroupBy(t => t.Destination)
																		.ToDictionary(xi => xi.Key, xi => xi.ToList());
	Dictionary<AbstractState, List<Transition>> transitions_by_origin = nG.Transitions.Where(t=> t.Trigger != fake).GroupBy(t => t.Origin)
																		.ToDictionary(xi => xi.Key, xi => xi.ToList());

	var initial_states = nG2.States.Except(transitions_by_destination.Keys);
	Dictionary<AbstractState, AbstractState> head = new Dictionary<UltraDES.AbstractState, UltraDES.AbstractState>();

	pi = new List<List<AbstractState>>();
	List<AbstractState> states = new List<AbstractState>();
	Queue<AbstractState> states_to_add = new Queue<UltraDES.AbstractState>();
	
	foreach (var ini_sta in nG2.States)
	{
		if(transitions_by_origin.ContainsKey(ini_sta) && !transitions_by_destination.ContainsKey(ini_sta)){				
			var current_state = ini_sta;
			states_to_add.Enqueue(current_state);
			while (states_to_add.Any())
			{
				current_state = states_to_add.Dequeue();
	
				if (!states.Contains(current_state))
				{
					states.Add(current_state);
					if(!head.ContainsKey(current_state)){
						head.Add(current_state, ini_sta);	
					}
					else{
						var temp_head = head[current_state];
						var temp_head_dictionary = new Dictionary<AbstractState, AbstractState>(head);
						foreach(var st in temp_head_dictionary.Where(xi=> xi.Value == ini_sta)){
							head[st.Key] = temp_head;
						}
					}
					
					
				}
	
				if (transitions_by_origin.ContainsKey(current_state))
				{
	
					foreach (var tr in transitions_by_origin[current_state])
					{
						if (!states.Contains(tr.Destination))
						{
							states_to_add.Enqueue(tr.Destination);
						}
	
	
					}
				}
	
			}
			pi.Add(states.ToList());
			states.Clear();
		}
		else if (!transitions_by_origin.ContainsKey(ini_sta) && !transitions_by_destination.ContainsKey(ini_sta))
		{
			var current_state = ini_sta;
			states.Add(current_state);
			pi.Add(states.ToList());
			head.Add(current_state, ini_sta);
			states.Clear();
		}
		
		
	}
	
	


	foreach (var list in pi)
	{
		foreach (var st in list)
		{
			Console.Write(st.ToString() + " ");
		}
		Console.WriteLine();
	}
	Console.WriteLine("\n");

	foreach (var st in head.Keys)
	{
		Console.WriteLine(st.ToString()  + " " + head[st].ToString());
		
	}

	return head;
	
}



List<List<AbstractState>> funcao2(DeterministicFiniteAutomaton H, List<Event> alpha)
{
	List<Transition> new_transitions = new List<Transition>();
	foreach (var tr in H.Transitions)
	{
		if (alpha.Contains(tr.Trigger))
		{
			new_transitions.Add(tr);
		}
	}
	var nG = new DeterministicFiniteAutomaton(new_transitions, H.InitialState, "newG");

	Event fake = new Event("fa", Controllability.Uncontrollable);
	foreach (var st in H.States)
	{
		new_transitions.Add(new Transition(st, fake, st));
	}

	var nG2 = new DeterministicFiniteAutomaton(new_transitions, H.InitialState, "newG2");

	//nG.ShowAutomaton("nG");
	//nG2.ShowAutomaton("nG2");

	Dictionary<AbstractState, List<Transition>> transitions_by_destination = nG.Transitions.GroupBy(t => t.Destination)
																		.ToDictionary(xi => xi.Key, xi => xi.ToList());
	Dictionary<AbstractState, List<Transition>> transitions_by_origin = nG.Transitions.GroupBy(t => t.Origin)
																		.ToDictionary(xi => xi.Key, xi => xi.ToList());

	var initial_states = nG2.States.Except(transitions_by_destination.Keys);

	List<List<AbstractState>> macrostates = new List<List<AbstractState>>();
	List<AbstractState> states = new List<AbstractState>();
	Queue<AbstractState> states_to_add = new Queue<UltraDES.AbstractState>();

	foreach (var ini_sta in nG2.States)
	{
		//if (!transitions_by_destination.ContainsKey(ini_sta))
		//{
		var current_state = ini_sta;
		states_to_add.Enqueue(current_state);
		while (states_to_add.Any())
		{
			current_state = states_to_add.Dequeue();

			if (!states.Contains(current_state))
			{
				states.Add(current_state);
			}

			if (transitions_by_origin.ContainsKey(current_state))
			{

				foreach (var tr in transitions_by_origin[current_state])
				{
					if (!states.Contains(tr.Destination))
					{
						states_to_add.Enqueue(tr.Destination);
					}


				}
			}

		}
		macrostates.Add(states.ToList());
		states.Clear();
		//}



	}

	/*
	foreach (var ini_sta in initial_states)
	{

		var current_state = ini_sta;
		states_to_add.Enqueue(current_state);
		while (states_to_add.Any())
		{
			current_state = states_to_add.Dequeue();
			
			if(!states.Contains(current_state)){
				states.Add(current_state);
			}
			
			if (transitions_by_origin.ContainsKey(current_state))
			{
				
				foreach (var tr in transitions_by_origin[current_state])
				{
					states_to_add.Enqueue(tr.Destination);
					
				}
			}

		}

		macrostates.Add(states.ToList());
		states.Clear();
	}
	*/

	foreach (var list in macrostates)
	{
		foreach (var st in list)
		{
			Console.Write(st.ToString() + " ");
		}
		Console.WriteLine();
	}
	
	//Nessa parte a partição é montada. Um dicionário cuja chave é o estado e o valor são os estados que estão na mesma classe que o estado é criado.
	Dictionary<AbstractState, List<AbstractState>> parti = new Dictionary<AbstractState, List<AbstractState>>();
	List<List<AbstractState>> parti2 = new List<List<AbstractState>>();
	List<Tuple<AbstractState, AbstractState>> parti3 = new List<Tuple<AbstractState, AbstractState>>();
	
	foreach(var st in nG2.States){
		parti3.Add(new Tuple<AbstractState, AbstractState>(st, st));
	}
	foreach(var list in macrostates){
		for(int st = 0; st < list.Count(); st++){
			for(int st2 = st; st2 < list.Count(); st2++){
				var new_pair = new Tuple<AbstractState, AbstractState>(list.ElementAt(st), list.ElementAt(st2));
				if(!parti3.Contains(new_pair)){
					parti3.Add(new_pair);
				}
			}
		}
	}
	
	
	foreach (var st in nG2.States)
	{
		parti.Add(st, new[] {st}.ToList());
	}
	foreach (var list in macrostates)
	{
		if (list.Count() > 1)
		{
			foreach (var st in list)
			{
				parti[st].AddRange(list.Except(new[] {st}.ToList()).ToList());
			}
		}
		
	}

	List<AbstractState> aux = new List<AbstractState>();
	List<AbstractState> processed = new List<AbstractState>();
	foreach (var st in nG2.States)
	{
		if (!processed.Contains(st))
		{
			foreach (var list in macrostates)
			{
				if (list.Contains(st))
				{
					aux.AddRange(list);
					processed.AddRange(list);
				}
			}
			parti2.Add(aux.ToList());
			aux.Clear();
		}

	}
	
	Console.WriteLine();
	foreach(var pair in parti3){
		Console.WriteLine("("+pair.Item1.ToString() +", "+pair.Item2.ToString()+")");
	}


	Console.WriteLine("\n");
	foreach (var pair in parti)
	{
		Console.Write(pair.Key.ToString()+ " ->");
		foreach (var st in pair.Value)
		{
			Console.Write(" " + st.ToString());
		}
		Console.WriteLine();
	}
	
	

	Console.WriteLine("\n");
	foreach (var list in parti2)
	
	{
		foreach (var st in list)
		{
			Console.Write(st.ToString() + " ");
		}
		Console.WriteLine();
	}



	return macrostates;
	
}



void funcao(DeterministicFiniteAutomaton H, List<AbstractEvent> alpha)
{

	var connected_components = 1;

	Dictionary<AbstractState, int> connected_component = H.States.ToDictionary(xi => xi, xi => 0);
	Dictionary<AbstractState, bool> visited =  H.States.ToDictionary(xi => xi, xi => false);

	List<Transition> new_transitions = new List<Transition>();
	foreach (var tr in H.Transitions)
	{
		
		new_transitions.Add(new Transition(tr.Destination, tr.Trigger, tr.Origin));
		
	}
	
	new_transitions.AddRange(H.Transitions);

	Dictionary<AbstractState, List<Transition>> undirected_transitions = new_transitions.Where(t => alpha.Contains(t.Trigger)).GroupBy(t => t.Origin)
																		.ToDictionary(xi => xi.Key, xi => xi.ToList());
																		

	

	Stack<AbstractState> states_to_visit = new Stack<UltraDES.AbstractState>();
	
	

	foreach (var st in H.States)
	{
		
		if (visited[st] == false)
		{
			states_to_visit.Push(st);
			var current_state = st;
			while (states_to_visit.Count() > 0)
			{

				current_state = states_to_visit.Peek();
				states_to_visit.Pop();

				if (visited[current_state] == false)
				{
					Console.Write(current_state.ToString() + " ");
					visited[current_state] = true;
				}

				if (undirected_transitions.Keys.Contains(current_state))
				{
					foreach (var t in undirected_transitions[current_state])
					{
						if (!visited[t.Destination])
						{
							states_to_visit.Push(t.Destination);
						}
					}
				}
				

			}
			Console.WriteLine();
			connected_components++;
		}
		

	}

	Console.WriteLine(connected_components-1);


}


void pequenaFabrica(out List<DeterministicFiniteAutomaton> p, out List<DeterministicFiniteAutomaton> spec, out List<Event> events)
{
	var st =
		Enumerable.Range(0, 6)
			.Select(ii =>
				new State(ii.ToString(),
					ii == 0
						? Marking.Marked
						: Marking.Unmarked)
			).ToArray();

	int numMaquinas = 3;
	// Creating Events 
	var aa =
		Enumerable.Range(1, numMaquinas)
			.Select(ii =>
				new Event("a" + ii.ToString(), Controllability.Controllable)
			).ToArray();

	var bb =
		Enumerable.Range(1, numMaquinas)
			.Select(ii =>
				new Event("b" + ii.ToString(), Controllability.Uncontrollable)
			).ToArray();



	//----------------------------
	// Plants
	//----------------------------


	var M =
		Enumerable.Range(1, numMaquinas)
			.Select(ii => new DeterministicFiniteAutomaton(
				new[]
				{
							new Transition(st[0], aa[ii-1], st[1]),
							new Transition(st[1], bb[ii-1], st[0])
				},
				st[0], "M" + ii.ToString())
			).ToArray();

	//----------------------------
	// Specifications
	//----------------------------

	var Esp =
		Enumerable.Range(1, numMaquinas - 1)
			.Select(ii => new DeterministicFiniteAutomaton(
				new[]
				{
							new Transition(st[0], bb[ii-1], st[1]),
							new Transition(st[1], aa[ii], st[0])
				},
				st[0], "E" + ii.ToString())
			).ToArray();

	p = M.ToList();
	spec = Esp.ToList();

	events = new List<Event>();
	events.AddRange(aa);
	events.AddRange(bb);

}