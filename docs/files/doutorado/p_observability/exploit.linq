<Query Kind="Statements">
  <Reference>&lt;RuntimeDirectory&gt;\System.ValueTuple.dll</Reference>
  <NuGetReference>UltraDES</NuGetReference>
  <Namespace>UltraDES</Namespace>
</Query>

var s = Enumerable.Range(0, 20).Select(i => new State($"s{i}", i == 0 ? Marking.Marked : Marking.Unmarked)).ToArray();



Event g = new Event("g", Controllability.Controllable);
Event d = new Event("d", Controllability.Controllable);
Event a = new Event("a", Controllability.Uncontrollable);
Event b = new Event("b", Controllability.Uncontrollable);
Event c = new Event("c", Controllability.Uncontrollable);
Event z = new Event("z", Controllability.Controllable);
Event f = new Event("f", Controllability.Uncontrollable);
Event e = new Event("e", Controllability.Uncontrollable);
Event y = new Event("y", Controllability.Uncontrollable);


// Creating Automata

var G = new DeterministicFiniteAutomaton(new[]
  {
	new Transition(s[0], g, s[0]),
	new Transition(s[0], a, s[1]),
	new Transition(s[0], d, s[4]),
	new Transition(s[1], b, s[2]),
	new Transition(s[2], c, s[3]),
	new Transition(s[3], d, s[0]),
	new Transition(s[3], g, s[5])
  }, s[0], "G");

var G2 = new DeterministicFiniteAutomaton(new[]
{
	new Transition(s[0], a, s[1]),
	new Transition(s[0], d, s[8]),
	new Transition(s[0], y, s[4]),
	new Transition(s[1], b, s[2]),
	new Transition(s[2], c, s[3]),
	new Transition(s[3], g, s[7]),
	new Transition(s[3], d, s[0]),
	new Transition(s[4], d, s[9]),
	new Transition(s[4], f, s[5]),
	new Transition(s[5], e, s[6]),
	new Transition(s[6], z, s[10]),
	new Transition(s[6], d, s[0]),
	
	
  }, s[0], "G2");


G2.ShowAutomaton();


Dictionary<AbstractState, List<Transition>> transitions_by_origin = G2.Transitions.GroupBy(t => t.Origin)
																	.ToDictionary(xi => xi.Key, xi=> xi.ToList());

List<Event> v1 =  new[] {g}.ToList();	
List<Event> v2 = new[] { a, b, c }.ToList();
List<List<Event>> ms = new List<List<Event>>();
ms.Add(new List<Event> { a});
ms.Add(new List<Event> { b});
ms.Add(new List<Event> { c });
ms.Add(new List<Event> { f });
ms.Add(new List<Event> { e });
ms.Add(new List<Event> { y });

var d2 = dist_states(s[0], s[4], transitions_by_origin, ms);

//var po = possible_states(transitions_by_origin, ms, s[1]);

var Est = build_estimator(G2, transitions_by_origin, ms);
Est.ShowAutomaton();


NondeterministicFiniteAutomaton build_estimator(DeterministicFiniteAutomaton H,  Dictionary<AbstractState, List<Transition>> transitions, List<List<Event>> manipulated_strings){
	 
	List<CompoundState> estimator_states = new List<CompoundState>();
	List<Transition> estimator_transitions = new List<Transition>();

	//creates all the states in the estimator
	foreach (var st in H.States)
	{
		if (transitions.Keys.Contains(st))
		{
			var states = possible_states(H, transitions, manipulated_strings, st);
			var new_estimator_state = new CompoundState(states.ToArray());
			if (!estimator_states.Contains(new_estimator_state))
			{
				estimator_states.Add(new_estimator_state);
			}
		}
		else
		{
			var new_estimator_state = new CompoundState(new[] { st}.ToArray());
			estimator_states.Add(new_estimator_state);
		}
	}
	//creates the transitions in the estimator
	foreach (var x in estimator_states)	{
		foreach (var q in x.S){
			foreach(var ev in feasible_events(transitions, q)){
				var new_state = delta(q, ev, transitions);
				var states = possible_states(H, transitions, manipulated_strings, new_state);
				var new_estimator_state = new CompoundState(states.ToArray());
				estimator_transitions.Add(new Transition(x, ev, estimator_states.ElementAt(estimator_states.IndexOf(new_estimator_state))));
			}
		}
	}

	//find initial state
	var initial_state = new CompoundState(possible_states(H, transitions, manipulated_strings, H.InitialState).ToArray());
	var initial_estimator_state = estimator_states.ElementAt(estimator_states.IndexOf(initial_state));
	
	var E = new NondeterministicFiniteAutomaton(estimator_transitions, initial_estimator_state, "Estimator");
	return E;
}

List<Event> feasible_events(Dictionary<AbstractState, List<Transition>> transitions, AbstractState state){

	List<Event> events = new List<Event>();

	if (transitions.Keys.Contains(state)){
		foreach(var t in transitions[state]){
			events.Add((Event)t.Trigger);
		}
	}
	
	return events;
	
}


List<AbstractState> possible_states(DeterministicFiniteAutomaton H, Dictionary<AbstractState, List<Transition>> transitions, List<List<Event>> manipulated_strings, AbstractState state)
{
	List<AbstractState> states = new List<AbstractState>();
	
	foreach(var st in H.States){
		var distance = dist_states(st, state, transitions, manipulated_strings);
		if(distance <= 1){
			states.Add(st);
		}
	}
	
	return states;
}


AbstractState delta(AbstractState state, Event ev, Dictionary<AbstractState, List<Transition>> transitions){
	if (!transitions.Keys.Contains(state)){
		return null;
	}
	
	var current_state = transitions[state];
	foreach (var t in current_state)
	{
		if (t.Trigger == ev)
		{
			return t.Destination;
		}
	}
	return null;	
}

AbstractState delta_strings(Dictionary<AbstractState, List<Transition>> transitions, List<Event> u)
{
	var current_state = transitions[s[0]];


	for (int i = 0; i < u.Count; i++)
	{
		var new_state = delta(current_state[0].Origin, u.ElementAt(i), transitions);
		if (new_state != null){
			current_state = transitions[new_state];
		}
		else{
			return null;
		}
	}
	
	return current_state[0].Origin;
}

																	
int dist(List<Event> str1, List<Event> str2, Dictionary<AbstractState, List<Transition>> transitions, List<List<Event>> manipulated_strings){
	
	var state_str1 = delta_strings(transitions, str1);
	var state_str2 = delta_strings(transitions, str2);
	
	var distance = 0;
	var current_state = state_str1;
	
	foreach(var x in manipulated_strings){
		
		foreach(var ev in x){
			var new_state = delta(current_state, ev, transitions);
			if (new_state != null){
				current_state = new_state;
				distance++;
			}
			else{
				distance = 0;
				break;
			}
		}
		if(current_state == state_str2){
			return distance;
		}

	}
	state_str1 = delta_strings(transitions, str2);
	state_str2 = delta_strings(transitions, str1);

	distance = 0;
	current_state = state_str1;

	foreach (var x in manipulated_strings)
	{

		foreach (var ev in x)
		{
			var new_state = delta(current_state, ev, transitions);
			if (new_state != null)
			{
				current_state = new_state;
				distance++;
			}
			else
			{
				distance = 0;
				break;
			}
		}
		if (current_state == state_str2)
		{
			return distance;
		}

	}

	return 10;

}

int dist_states(AbstractState st1, AbstractState st2, Dictionary<AbstractState, List<Transition>> transitions, List<List<Event>> manipulated_strings)
{

	var distance = 0;
	var current_state = st1;
	
	if(st1 == st2){
		return 0;
	}
	else
	{
		foreach (var x in manipulated_strings)
		{
			current_state = st1;
			foreach (var ev in x)
			{
				var new_state = delta(current_state, ev, transitions);
				if (new_state != null)
				{
					current_state = new_state;
					distance++;
				}
				else
				{
					distance = 0;
					break;
				}
			}
			if (current_state == st2)
			{
				return distance;
			}

		}

		distance = 0;
		current_state = st2;

		foreach (var x in manipulated_strings)
		{
			current_state = st2;
			foreach (var ev in x)
			{
				var new_state = delta(current_state, ev, transitions);
				if (new_state != null)
				{
					current_state = new_state;
					distance++;
				}
				else
				{
					distance = 0;
					break;
				}
			}
			if (current_state == st1)
			{
				return distance;
			}

		}

		return 10;
	}



}


//IEnumerable<IGrouping<AbstractState, Transition>> query = from t in G.Transitions
//										 		  group t by t.Origin;

//G.ShowAutomaton();