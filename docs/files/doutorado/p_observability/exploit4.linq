<Query Kind="Statements">
  <Reference>&lt;RuntimeDirectory&gt;\System.ValueTuple.dll</Reference>
  <NuGetReference>UltraDES</NuGetReference>
  <Namespace>UltraDES</Namespace>
</Query>

/*
Outra opção:

-remover as transições com eventos que não estão em \Sigma_v;
-fazer o trim
-identificar os estados inconsistentes
-encontrar os caminhos entre eles

*/

var s = Enumerable.Range(0, 20).Select(ii => new State($"s{ii}", ii == 0 ? Marking.Marked : Marking.Unmarked)).ToArray();



Event g = new Event("g", Controllability.Uncontrollable);
Event d = new Event("d", Controllability.Uncontrollable);
Event a = new Event("a", Controllability.Uncontrollable);
Event b = new Event("b", Controllability.Uncontrollable);
Event c = new Event("c", Controllability.Uncontrollable);
Event h = new Event("h", Controllability.Uncontrollable);
Event f = new Event("f", Controllability.Uncontrollable);
Event e = new Event("e", Controllability.Uncontrollable);
Event i = new Event("i", Controllability.Uncontrollable);
Event j = new Event("j", Controllability.Uncontrollable);
Event k = new Event("k", Controllability.Uncontrollable);
Event l = new Event("l", Controllability.Uncontrollable);
Event m = new Event("m", Controllability.Uncontrollable);
Event y = new Event("y", Controllability.Controllable);
Event x = new Event("x", Controllability.Controllable);


//noel2010
var G3 = new DeterministicFiniteAutomaton(new[]
{
	new Transition(s[0], a, s[1]),
	new Transition(s[0], x, s[7]),
	new Transition(s[0], y, s[0]),
	new Transition(s[0], b, s[2]),
	new Transition(s[0], c, s[2]),
	new Transition(s[1], b, s[2]),
	new Transition(s[2], d, s[3]),
	new Transition(s[2], e, s[4]),
	new Transition(s[3], e, s[4]),
	new Transition(s[4], f, s[5]),
	new Transition(s[5], y, s[8]),
	new Transition(s[5], x, s[0]),
	new Transition(s[0], g, s[6]),
	new Transition(s[6], h, s[4]),
	new Transition(s[0], h, s[4]),

  }, s[0], "G3");

var K3 = new DeterministicFiniteAutomaton(new[]
{
	new Transition(s[0], a, s[1]),
	new Transition(s[0], x, s[7]),
	new Transition(s[0], b, s[2]),
	new Transition(s[0], c, s[2]),
	new Transition(s[1], b, s[2]),
	new Transition(s[2], d, s[3]),
	new Transition(s[2], e, s[4]),
	new Transition(s[3], e, s[4]),
	new Transition(s[4], f, s[5]),
	new Transition(s[5], x, s[0]),
	new Transition(s[0], g, s[6]),
	new Transition(s[6], h, s[4]),
	new Transition(s[0], h, s[4]),

  }, s[0], "K3");


var S = DeterministicFiniteAutomaton.MonolithicSupervisor(new[] { G3 }, new[] { K3 });
//S.ShowAutomaton("S");
List<Event> v2 = new[] { a, b, c, d, e, f, g, h}.ToList();


var G = delete_non_vulnerable_events(S, v2);
//G.ShowAutomaton("G");

var ci = inconsistent_states(S, G3);

var p = FindAllPaths(G, ci.ElementAt(0).Item1, ci.ElementAt(0).Item2);
print_paths(p);

analyse_paths(p);
print_paths(p);


void analyse_paths(List<List<AbstractEvent>> paths){

	List<List<AbstractEvent>> attackers = new List<List<AbstractEvent>>();
	
	foreach(var path in paths){	
		var pl = path.Count();
		attackers.Add(path);
		print_list(path);
		Console.WriteLine();
		for(int ii = 1; ii < pl; ii++){
			var tl = path.GetRange(0, ii);
			var tl2 = path.GetRange(ii, pl-ii);
			attackers.Add(tl);
			attackers.Add(tl2);
			print_list(tl);
			Console.Write(" and ");
			print_list(tl2);
			Console.WriteLine();
		}
	}
	
}

var yui=2;
List<List<AbstractEvent>> FindAllPaths(DeterministicFiniteAutomaton H, AbstractState from, AbstractState to)
{
    Queue<Tuple<AbstractState, List<AbstractState>, List<AbstractEvent>>> nodes = new Queue<Tuple<AbstractState, List<AbstractState>, List<AbstractEvent>>>();
    nodes.Enqueue(new Tuple<AbstractState, List<AbstractState>, List<AbstractEvent>>(from, new List<AbstractState>(), new List<AbstractEvent>()));
	List<List<AbstractState>> paths = new List<List<AbstractState>>();
	List<List<AbstractEvent>> paths_events = new List<List<AbstractEvent>>();
	
	

	Dictionary<AbstractState, List<Transition>> transitions_by_origin = H.Transitions.GroupBy(t => t.Origin)
																		.ToDictionary(xi => xi.Key, xi => xi.ToList());


	while(nodes.Any())
    {
        var current = nodes.Dequeue();
        var currentNode = current.Item1;

        if (current.Item2.Contains(currentNode))
        {
            continue;
        }

        current.Item2.Add(currentNode);
		

        if (currentNode == to)
        {
            paths.Add(current.Item2);
			paths_events.Add(current.Item3);
            continue;
        }

        foreach(var edge in transitions_by_origin[currentNode])
		{
			
			var le = new List<AbstractEvent>(current.Item3);
			le.Add(edge.Trigger);
			var tuple = new Tuple<AbstractState, List<AbstractState>, List<AbstractEvent>> (edge.Destination, new List<AbstractState>(current.Item2), le);
            nodes.Enqueue(tuple);
			
        }
    }

    return paths_events;
} 

//https://en.wikipedia.org/wiki/Breadth-first_search

void print_paths(List<List<AbstractEvent>> le){
	
	Console.WriteLine("Paths: ");
	foreach(var path in le){
		foreach(var ev in path){
			Console.Write(ev.ToString() + " ");
		}
		Console.WriteLine();
	}
	
}

void print_list(List<AbstractEvent> list){
	
	Console.Write("(");
	foreach(var element in list){
		Console.Write(element.ToString());
	}
	Console.Write(")");
}

void print_attackers(List<List<AbstractEvent>> att)
{

	Console.WriteLine("Attackers: ");
	foreach (var at in att)
	{
		foreach (var ev in at)
		{
			Console.Write(ev.ToString() + " ");
		}
		Console.WriteLine();
	}

}

DeterministicFiniteAutomaton delete_non_vulnerable_events(DeterministicFiniteAutomaton H, List<Event> vulnerable_events)
{
	List<Transition> delta = new List<Transition>();

	foreach (var t in S.Transitions)
	{
		if (v2.Contains(t.Trigger))
		{
			delta.Add(t);
		}
	}

	var new_automaton = new DeterministicFiniteAutomaton(delta, H.InitialState, H.Name.ToString() + "2");

	return new_automaton;
}


List<(AbstractState, AbstractState)> inconsistent_states(DeterministicFiniteAutomaton Sup, DeterministicFiniteAutomaton H)
{

	var disablements = Sup.DisabledEvents(new[] { H });
	List<(AbstractState, AbstractState)> CI = new List<(AbstractState, AbstractState)>();

	Console.WriteLine("Inconsistent states:");

	foreach (var st in Sup.States)
	{
		foreach (var st2 in Sup.States)
		{
			if (st != st2)
			{
				if (feasible_event(Sup, st).Intersect(disablements[st2]).Count() > 0 || feasible_event(Sup, st2).Intersect(disablements[st]).Count() > 0)
				{
					//if (!CI.Contains((st2, st)))
					//{
					CI.Add((st, st2));
					//}
					//Console.WriteLine("\n States " + st.ToString() + " and " + st2.ToString() + " are not control consistent");

				}
			}

		}

	}


	foreach (var pair in CI)
	{
		Console.WriteLine(pair.Item1.ToString() + ", " + pair.Item2.ToString());
	}

	return CI;
}

List<AbstractEvent> feasible_event(DeterministicFiniteAutomaton H, AbstractState state)
{

	List<AbstractEvent> events = new List<AbstractEvent>();
	foreach (var t in H.Transitions.Where(jj => (jj.Origin == state)))
	{
		events.Add(t.Trigger);
	}
	return events;
}