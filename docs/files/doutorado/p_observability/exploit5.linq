<Query Kind="Statements">
  <Reference>&lt;RuntimeDirectory&gt;\System.ValueTuple.dll</Reference>
  <NuGetReference>UltraDES</NuGetReference>
  <Namespace>UltraDES</Namespace>
</Query>

var s = Enumerable.Range(0, 20).Select(ii => new State($"s{ii}", ii == 0 ? Marking.Marked : Marking.Unmarked)).ToArray();



Event g = new Event("g", Controllability.Uncontrollable);
Event d = new Event("d", Controllability.Uncontrollable);
Event a = new Event("a", Controllability.Uncontrollable);
Event b = new Event("b", Controllability.Uncontrollable);
Event c = new Event("c", Controllability.Uncontrollable);
Event h = new Event("h", Controllability.Uncontrollable);
Event f = new Event("f", Controllability.Uncontrollable);
Event e = new Event("e", Controllability.Uncontrollable);
Event i = new Event("i", Controllability.Uncontrollable);
Event j = new Event("j", Controllability.Uncontrollable);
Event k = new Event("k", Controllability.Uncontrollable);
Event l = new Event("l", Controllability.Uncontrollable);
Event m = new Event("m", Controllability.Uncontrollable);
Event y = new Event("y", Controllability.Controllable);
Event x = new Event("x", Controllability.Controllable);


var G8 = new DeterministicFiniteAutomaton(new[]
{
	new Transition(s[0], c, s[1]),
	new Transition(s[1], d, s[2]),
	new Transition(s[2], e, s[3]),
	new Transition(s[3], f, s[4]),
	new Transition(s[0], a, s[5]),
	new Transition(s[5], b, s[6]),
	new Transition(s[6], g, s[4]),

  }, s[0], "G8");


//G8.ShowAutomaton("P");
//Matthews2020
var G7 = new DeterministicFiniteAutomaton(new[]
{
	new Transition(s[0], a, s[1]),
	new Transition(s[1], b, s[2]),
	new Transition(s[2], c, s[3]),
	new Transition(s[3], d, s[4]),
	new Transition(s[4], e, s[5]),
	new Transition(s[5], f, s[6]),
	new Transition(s[0], g, s[3]),
	new Transition(s[2], h, s[5]),
	new Transition(s[4], i, s[1]),
	new Transition(s[0], x, s[7]),
	new Transition(s[0], y, s[0]),
	new Transition(s[6], y, s[8]),
	new Transition(s[6], x, s[0]),

  }, s[0], "G7");

var K7 = new DeterministicFiniteAutomaton(new[]
{
	new Transition(s[0], a, s[1]),
	new Transition(s[1], b, s[2]),
	new Transition(s[2], c, s[3]),
	new Transition(s[3], d, s[4]),
	new Transition(s[4], e, s[5]),
	new Transition(s[5], f, s[6]),
	new Transition(s[0], g, s[3]),
	new Transition(s[2], h, s[5]),
	new Transition(s[4], i, s[1]),
	new Transition(s[0], y, s[0]),
	new Transition(s[6], x, s[0]),

  }, s[0], "K7");

//wang2006
var G6 = new DeterministicFiniteAutomaton(new[]
{
	new Transition(s[0], a, s[1]),
	new Transition(s[1], b, s[2]),
	new Transition(s[2], c, s[3]),
	new Transition(s[3], e, s[4]),
	new Transition(s[4], f, s[5]),
	new Transition(s[3], d, s[5]),
	new Transition(s[5], g, s[6]),
	new Transition(s[6], h, s[7]),
	new Transition(s[7], i, s[8]),
	new Transition(s[4], g, s[6]),
	new Transition(s[4], h, s[7]),
	new Transition(s[4], i, s[8]),
	new Transition(s[0], x, s[9]),
	new Transition(s[0], y, s[0]),
	new Transition(s[8], y, s[10]),
	new Transition(s[8], x, s[0]),

  }, s[0], "G6");

var K6 = new DeterministicFiniteAutomaton(new[]
{
	new Transition(s[0], a, s[1]),
	new Transition(s[1], b, s[2]),
	new Transition(s[2], c, s[3]),
	new Transition(s[3], e, s[4]),
	new Transition(s[4], f, s[5]),
	new Transition(s[3], d, s[5]),
	new Transition(s[5], g, s[6]),
	new Transition(s[6], h, s[7]),
	new Transition(s[7], i, s[8]),
	new Transition(s[4], g, s[6]),
	new Transition(s[4], h, s[7]),
	new Transition(s[4], i, s[8]),
	new Transition(s[0], y, s[0]),
	new Transition(s[8], x, s[0]),

  }, s[0], "K6");

//zeng2019
var G5 = new DeterministicFiniteAutomaton(new[]
{
	new Transition(s[0], a, s[1]),
	new Transition(s[1], b, s[2]),
	new Transition(s[1], c, s[2]),
	new Transition(s[2], f, s[3]),
	new Transition(s[1], d, s[4]),
	new Transition(s[4], e, s[3]),
	new Transition(s[0], x, s[5]),
	new Transition(s[0], y, s[0]),
	new Transition(s[3], y, s[6]),
	new Transition(s[3], x, s[0]),

  }, s[0], "G5");

var K5 = new DeterministicFiniteAutomaton(new[]
{
	new Transition(s[0], a, s[1]),
	new Transition(s[1], b, s[2]),
	new Transition(s[1], c, s[2]),
	new Transition(s[2], f, s[3]),
	new Transition(s[1], d, s[4]),
	new Transition(s[4], e, s[3]),
	new Transition(s[0], y, s[0]),
	new Transition(s[3], x, s[0]),

  }, s[0], "K5");

//zeng2019
var G4 = new DeterministicFiniteAutomaton(new[]
{
	new Transition(s[0], a, s[1]),
	new Transition(s[1], b, s[2]),
	new Transition(s[2], c, s[3]),
	new Transition(s[3], d, s[4]),
	new Transition(s[4], e, s[5]),
	new Transition(s[0], f, s[6]),
	new Transition(s[6], g, s[4]),
	new Transition(s[6], h, s[4]),
	new Transition(s[0], i, s[7]),
	new Transition(s[7], j, s[5]),
	new Transition(s[7], k, s[5]),
	new Transition(s[7], l, s[5]),
	new Transition(s[0], m, s[5]),
	new Transition(s[0], x, s[8]),
	new Transition(s[0], y, s[0]),
	new Transition(s[5], y, s[9]),
	new Transition(s[5], x, s[0]),

  }, s[0], "G4");

var K4 = new DeterministicFiniteAutomaton(new[]
{
	new Transition(s[0], a, s[1]),
	new Transition(s[1], b, s[2]),
	new Transition(s[2], c, s[3]),
	new Transition(s[3], d, s[4]),
	new Transition(s[4], e, s[5]),
	new Transition(s[0], f, s[6]),
	new Transition(s[6], g, s[4]),
	new Transition(s[6], h, s[4]),
	new Transition(s[0], i, s[7]),
	new Transition(s[7], j, s[5]),
	new Transition(s[7], k, s[5]),
	new Transition(s[7], l, s[5]),
	new Transition(s[0], m, s[5]),
	new Transition(s[0], y, s[0]),
	new Transition(s[5], x, s[0]),

  }, s[0], "K4");

//noel2010
var G3 = new DeterministicFiniteAutomaton(new[]
{
	new Transition(s[0], a, s[1]),
	new Transition(s[0], x, s[7]),
	new Transition(s[0], y, s[0]),
	new Transition(s[0], b, s[2]),
	new Transition(s[0], c, s[2]),
	new Transition(s[1], b, s[2]),
	new Transition(s[2], d, s[3]),
	new Transition(s[2], e, s[4]),
	new Transition(s[3], e, s[4]),
	new Transition(s[4], f, s[5]),
	new Transition(s[5], y, s[8]),
	new Transition(s[5], x, s[0]),
	new Transition(s[0], g, s[6]),
	new Transition(s[6], h, s[4]),
	new Transition(s[0], h, s[4]),

  }, s[0], "G3");

var K3 = new DeterministicFiniteAutomaton(new[]
{
	new Transition(s[0], a, s[1]),
	new Transition(s[0], x, s[7]),
	new Transition(s[0], b, s[2]),
	new Transition(s[0], c, s[2]),
	new Transition(s[1], b, s[2]),
	new Transition(s[2], d, s[3]),
	new Transition(s[2], e, s[4]),
	new Transition(s[3], e, s[4]),
	new Transition(s[4], f, s[5]),
	new Transition(s[5], x, s[0]),
	new Transition(s[0], g, s[6]),
	new Transition(s[6], h, s[4]),
	new Transition(s[0], h, s[4]),

  }, s[0], "K3");


var G2 = new DeterministicFiniteAutomaton(new[]
{
	new Transition(s[0], a, s[1]),
	new Transition(s[0], d, s[8]),
	new Transition(s[0], y, s[4]),
	new Transition(s[1], b, s[2]),
	new Transition(s[2], c, s[3]),
	new Transition(s[3], g, s[7]),
	new Transition(s[3], d, s[0]),
	new Transition(s[4], d, s[9]),
	new Transition(s[4], f, s[5]),
	new Transition(s[5], e, s[6]),
	new Transition(s[6], d, s[0]),

  }, s[0], "G2");

var K2 = new DeterministicFiniteAutomaton(new[]
{
	new Transition(s[0], a, s[1]),
	new Transition(s[0], y, s[4]),
	new Transition(s[1], b, s[2]),
	new Transition(s[2], c, s[3]),
	new Transition(s[3], d, s[0]),
	new Transition(s[4], f, s[5]),
	new Transition(s[5], e, s[6]),
	new Transition(s[6], d, s[0]),

  }, s[0], "K2");

var G9 = new DeterministicFiniteAutomaton(new[]
{
	new Transition(s[0], a, s[1]),
	new Transition(s[1], b, s[2]),
	new Transition(s[2], c, s[3]),
	new Transition(s[3], f, s[2]),
	new Transition(s[2], e, s[1]),
	new Transition(s[1], d, s[0]),
	new Transition(s[0], g, s[2]),
	new Transition(s[1], h, s[3]),
	new Transition(s[3], i, s[1]),
	new Transition(s[2], j, s[0]),
	new Transition(s[0], k, s[3]),
	new Transition(s[3], l, s[0]),
	new Transition(s[0], x, s[4]),
	new Transition(s[0], y, s[0]),
	new Transition(s[3], y, s[5]),
	new Transition(s[3], x, s[0]),

  }, s[0], "G9");

var K9 = new DeterministicFiniteAutomaton(new[]
{
	new Transition(s[0], a, s[1]),
	new Transition(s[1], b, s[2]),
	new Transition(s[2], c, s[3]),
	new Transition(s[3], f, s[2]),
	new Transition(s[2], e, s[1]),
	new Transition(s[1], d, s[0]),
	new Transition(s[0], g, s[2]),
	new Transition(s[1], h, s[3]),
	new Transition(s[3], i, s[1]),
	new Transition(s[2], j, s[0]),
	new Transition(s[0], k, s[3]),
	new Transition(s[3], l, s[0]),
	
	new Transition(s[0], y, s[0]),
	
	new Transition(s[3], x, s[0]),

  }, s[0], "K9");


//G7.ShowAutomaton();
//K7.ShowAutomaton();
pequenaFabrica(out var plants, out var specs, out var evs);
//DeterministicFiniteAutomaton.FromWmodFile(@"D:\Dropbox\Doutorado\Plantas linqpad\tank_process.wmod", out var plants, out var specs);
//var G9 = DeterministicFiniteAutomaton.ParallelComposition(plants);
//var K9 = DeterministicFiniteAutomaton.ParallelComposition(specs);


//var S = DeterministicFiniteAutomaton.MonolithicSupervisor(new[] { G7 }, new[] { K7});
var S = DeterministicFiniteAutomaton.MonolithicSupervisor(plants.ToArray(), specs.ToArray());
//S.ShowAutomaton("S");
//var disS = S.DisabledEvents(new[] { G3 });
//S.ShowAutomaton("S");
//var dis = S.DisabledEvents(new[] { G });

//Dictionary<AbstractState, List<Transition>> transitions_by_origin = G2.Transitions.GroupBy(t => t.Origin)
//																	.ToDictionary(xi => xi.Key, xi => xi.ToList());

//Dictionary<AbstractState, List<Transition>> transitions_by_destination = G2.Transitions.GroupBy(t => t.Destination)
//																	.ToDictionary(xi => xi.Key, xi => xi.ToList());

List<Event> v2 = new[] { a, b, c, d, e,  f, g, h, i, j, k, l, m}.ToList();
//List<Event> v2 = new[] { a, b, c, d, e, f, g, h }.ToList();
//List<AbstractEvent> v2 = S.Events.Where(evt => evt.Controllability == UltraDES.Controllability.Uncontrollable).ToList();
//List<Event> v2 = evs.Where(evt => evt.Controllability == UltraDES.Controllability.Uncontrollable).ToList();
//List<Event> v2 = new[] { a, b, c, d, e,  f}.ToList();
//List<Event> v2 = new[] { a, b, c, d, e,  f, g, h, i}.ToList();

//var po = neighbor_states2(S, S.States.ElementAt(1), 10, v2);
//var ci = inconsistent_states(S, G3);


var po1 = check_Pobservability6(G9, K9, v2);



List<Event> v1 = new[] { g }.ToList();

List<(AbstractState, AbstractState)> inconsistent_states2(DeterministicFiniteAutomaton Sup, DeterministicFiniteAutomaton H, List<DeterministicFiniteAutomaton> sub_automata)
{

	var disablements = Sup.DisabledEvents(new[] { H });
	List<(AbstractState, AbstractState)> CI = new List<(AbstractState, AbstractState)>();

	foreach (var aut in sub_automata)
	{
		//Console.WriteLine("Automaton "+ aut.ToString());
		//Console.WriteLine("Inconsistent states:");

		foreach (var st in aut.States)
		{
			foreach (var st2 in aut.States)
			{
				if (st != st2)
				{
					if (feasible_event(Sup, st).Intersect(disablements[st2]).Count() > 0 || feasible_event(Sup, st2).Intersect(disablements[st]).Count() > 0)
					{
						//if (!CI.Contains((st2, st)))
						//{
						CI.Add((st, st2));
						//}
						//Console.WriteLine("\n States " + st.ToString() + " and " + st2.ToString() + " are not control consistent");

					}
				}

			}

		}
	}

/*
	foreach (var pair in CI)
	{
		Console.WriteLine(pair.Item1.ToString() + ", " + pair.Item2.ToString());
	}
*/
	return CI;
}

List<(AbstractState, AbstractState)> inconsistent_states(DeterministicFiniteAutomaton Sup, DeterministicFiniteAutomaton H)
{

	var disablements = Sup.DisabledEvents(new[] { H });
	List<(AbstractState, AbstractState)> CI = new List<(AbstractState, AbstractState)>();

	Console.WriteLine("Inconsistent states:");

	foreach (var st in Sup.States)
	{
		foreach (var st2 in Sup.States)
		{
			if (st != st2)
			{
				if (feasible_event(Sup, st).Intersect(disablements[st2]).Count() > 0 || feasible_event(Sup, st2).Intersect(disablements[st]).Count() > 0)
				{
					//if (!CI.Contains((st2, st)))
					//{
					CI.Add((st, st2));
					//}
					//Console.WriteLine("\n States " + st.ToString() + " and " + st2.ToString() + " are not control consistent");

				}
			}

		}

	}


	foreach (var pair in CI)
	{
		Console.WriteLine(pair.Item1.ToString() + ", " + pair.Item2.ToString());
	}

	return CI;
}

List<List<T>> GetAllCombos<T>(List<T> list)
{
	List<List<T>> result = new List<List<T>>();
	// head
	result.Add(new List<T>());
	result.Last().Add(list[0]);
	if (list.Count == 1)
		return result;
	// tail
	List<List<T>> tailCombos = GetAllCombos(list.Skip(1).ToList());
	tailCombos.ForEach(combo =>
	{
		result.Add(new List<T>(combo));
		combo.Add(list[0]);
		result.Add(new List<T>(combo));
	});
	return result;
}


Boolean check_Pobservability4(DeterministicFiniteAutomaton H, DeterministicFiniteAutomaton desired_language, List<Event> vulnerable_events)
{

	var attack_set = GetAllCombos(vulnerable_events);
	var sup = DeterministicFiniteAutomaton.MonolithicSupervisor(new[] { H }, new[] { desired_language }).SimplifyStatesName();
	sup.ShowAutomaton("S");
	List<List<Event>> forbidden_events = new List<List<Event>>();
	List<List<Event>> forbidden_events2 = new List<List<Event>>();

	var ci = inconsistent_states(sup, H);
	var number_of_events = vulnerable_events.Count();

	while (number_of_events >= 1)
	{
		foreach (var attacker in attack_set.Where(at => at.Count() == number_of_events).ToList())
		{
			foreach (var ev in attacker)
			{
				Console.Write(ev.ToString() + " ");
			}
			foreach (var fe in forbidden_events2)
			{
				if (attacker.Intersect(fe).Count() == fe.Count())
				{
					Console.Write("- Not P-observable*");
					forbidden_events2.Add(attacker);
					goto teste;
				}

			}


			foreach (var pair in ci)
			{
				var possible_states1 = neighbor_states2(sup, pair.Item1, 10, attacker);
				possible_states1.Add(pair.Item1);
				var possible_states2 = neighbor_states2(sup, pair.Item2, 10, attacker);
				possible_states2.Add(pair.Item2);

				if (possible_states1.Intersect(possible_states2).Count() > 0)
				{
					Console.Write("- Not P-observable");
					if (!forbidden_events.Contains(attacker))
					{
						forbidden_events.Add(attacker);
						forbidden_events2.Add(attacker);
					}
				}
				else
				{
					Console.Write("- OK");
				}
			}
		teste:;
			Console.WriteLine();

		}
		number_of_events++;
	}

	Console.WriteLine("Eventos proibidos: ");
	foreach (var set in forbidden_events)
	{
		foreach (var ev in set)
		{
			Console.Write(ev.ToString() + " ");
		}
		Console.WriteLine();

	}




	return true;

}

Boolean check_Pobservability3(DeterministicFiniteAutomaton H, DeterministicFiniteAutomaton desired_language, List<Event> vulnerable_events)
{

	var attack_set = GetAllCombos(vulnerable_events);
	var sup = DeterministicFiniteAutomaton.MonolithicSupervisor(new[] { H }, new[] { desired_language }).SimplifyStatesName();
	sup.ShowAutomaton("S");
	List<List<Event>> forbidden_events = new List<List<Event>>();
	List<List<Event>> forbidden_events2 = new List<List<Event>>();

	var ci = inconsistent_states(sup, H);
	var number_of_events = 1;

	while (number_of_events < vulnerable_events.Count())
	{
		foreach (var attacker in attack_set.Where(at => at.Count() == number_of_events).ToList())
		{
			foreach (var ev in attacker)
			{
				Console.Write(ev.ToString() + " ");
			}
			/*
			foreach (var fe in forbidden_events2)
			{
				if (attacker.Intersect(fe).Count() == fe.Count())
				{
					Console.Write("- Not P-observable*");
					forbidden_events2.Add(attacker);
					goto teste;
				}

			}
			*/

			foreach (var pair in ci)
			{
				var possible_states1 = neighbor_states2(sup, pair.Item1, 10, attacker);
				possible_states1.Add(pair.Item1);
				var possible_states2 = neighbor_states2(sup, pair.Item2, 10, attacker);
				possible_states2.Add(pair.Item2);
				Console.Write(pair.Item1.ToString() + ", " + pair.Item2.ToString());

				if (possible_states1.Intersect(possible_states2).Count() > 0)
				{
					Console.WriteLine("- Not P-observable");
					if (!forbidden_events.Contains(attacker))
					{
						forbidden_events.Add(attacker);
						forbidden_events2.Add(attacker);
					}
				}
				else
				{
					Console.WriteLine("- OK");
				}
			}
		teste:;
			Console.WriteLine();

		}
		number_of_events++;
	}

	Console.WriteLine("Eventos proibidos: ");
	foreach (var set in forbidden_events)
	{
		foreach (var ev in set)
		{
			Console.Write(ev.ToString() + " ");
		}
		Console.WriteLine();
		
		/*
		Console.WriteLine("Testando as novas combinações: ");

		var new_attacker = GetAllCombos(set).Where(at => at.Count() < set.Count());
		foreach (var attacker in new_attacker)
		{

			foreach (var attacker2 in new_attacker)
			{

				foreach (var pair in ci)
				{
					var possible_states1 = neighbor_states2(sup, pair.Item1, 10, attacker);
					possible_states1.Add(pair.Item1);
					var possible_states2 = neighbor_states2(sup, pair.Item2, 10, attacker2);
					possible_states2.Add(pair.Item2);

					if (possible_states1.Intersect(possible_states2).Count() > 0)
					{

						foreach (var ev in attacker)
						{
							Console.Write(ev.ToString() + " ");
						}
						Console.Write(" and ");
						foreach (var ev in attacker2)
						{
							Console.Write(ev.ToString() + " ");
						}
						//Console.WriteLine();

						Console.WriteLine("- Not P-observable");
					}
					else
					{
						//Console.Write("- OK");
					}
				}
				//Console.WriteLine();
			}
		}
		*/
	}


	return true;


}

Boolean check_Pobservability6(DeterministicFiniteAutomaton H, DeterministicFiniteAutomaton desired_language, List<Event> vulnerable_events)
{

	var attack_set = GetAllCombos(vulnerable_events);
	var sup = DeterministicFiniteAutomaton.MonolithicSupervisor(new[] { H }, new[] { desired_language }).SimplifyStatesName();
	//sup.ShowAutomaton("S");
	List<Transition> new_transitions = new List<Transition> ();
	foreach(var tr in sup.Transitions){
		if(vulnerable_events.Contains(tr.Trigger)){
			new_transitions.Add(tr);
		}
	}
	
	var nG = new DeterministicFiniteAutomaton(new_transitions, sup.InitialState, "newG");
	//nG.ShowAutomaton("nG");

	Dictionary<AbstractState, List<Transition>> transitions_by_destination = nG.Transitions.GroupBy(t => t.Destination)
																		.ToDictionary(xi => xi.Key, xi => xi.ToList());

	Dictionary<AbstractState, List<Transition>> transitions_by_origin = nG.Transitions.GroupBy(t => t.Origin)
																		.ToDictionary(xi => xi.Key, xi => xi.ToList());
																		
	var initial_states = nG.States.Except(transitions_by_destination.Keys);	
	Queue<AbstractState> states_to_add = new Queue<UltraDES.AbstractState>();
	List<DeterministicFiniteAutomaton> new_automata = new List<DeterministicFiniteAutomaton>();
	List<Transition> new_tr = new List<Transition>();
	foreach(var ini_sta in initial_states){
		
		var current_state = ini_sta;
		states_to_add.Enqueue(current_state);
		while (states_to_add.Any())
		{
			current_state = states_to_add.Dequeue();
			if (transitions_by_origin.ContainsKey(current_state))
			{
				foreach (var tr in transitions_by_origin[current_state])
				{
					states_to_add.Enqueue(tr.Destination);
					new_tr.Add(tr);
				}
			}
			
		}
		
		new_automata.Add(new DeterministicFiniteAutomaton(new_tr, ini_sta, ini_sta.ToString()));
		new_tr.Clear();
	}
	
	List<(AbstractState, AbstractState)> ci = new List<(AbstractState, AbstractState)>();
	foreach(var aut in new_automata){
		//aut.ShowAutomaton();
		var ci2 = inconsistent_states2(sup, H, new_automata);
		ci.AddRange(ci2);
	}

	List<List<Event>> forbidden_events = new List<List<Event>>();
	List<List<Event>> forbidden_events2 = new List<List<Event>>();

	//var ci = inconsistent_states(sup, H);
	var number_of_events = 1;

	while (number_of_events < vulnerable_events.Count())
	{
		foreach (var attacker in attack_set.Where(at => at.Count() == number_of_events).ToList())
		{
			foreach (var ev in attacker)
			{
				Console.Write(ev.ToString() + " ");
			}
			/*
			foreach (var fe in forbidden_events2)
			{
				if (attacker.Intersect(fe).Count() == fe.Count())
				{
					Console.Write("- Not P-observable*");
					forbidden_events2.Add(attacker);
					goto teste;
				}

			}
			*/

			foreach (var pair in ci)
			{
				var possible_states1 = neighbor_states2(sup, pair.Item1, 10, attacker);
				possible_states1.Add(pair.Item1);
				var possible_states2 = neighbor_states2(sup, pair.Item2, 10, attacker);
				possible_states2.Add(pair.Item2);
				Console.Write(pair.Item1.ToString() + ", " + pair.Item2.ToString());

				if (possible_states1.Intersect(possible_states2).Count() > 0)
				{
					Console.WriteLine("- Not P-observable");
					if (!forbidden_events.Contains(attacker))
					{
						forbidden_events.Add(attacker);
						forbidden_events2.Add(attacker);
					}
				}
				else
				{
					Console.WriteLine("- OK");
				}
			}
		teste:;
			Console.WriteLine();

		}
		number_of_events++;
	}

	Console.WriteLine("Eventos proibidos: ");
	foreach (var set in forbidden_events)
	{
		foreach (var ev in set)
		{
			Console.Write(ev.ToString() + " ");
		}
		Console.WriteLine();

		/*
		Console.WriteLine("Testando as novas combinações: ");

		var new_attacker = GetAllCombos(set).Where(at => at.Count() < set.Count());
		foreach (var attacker in new_attacker)
		{

			foreach (var attacker2 in new_attacker)
			{

				foreach (var pair in ci)
				{
					var possible_states1 = neighbor_states2(sup, pair.Item1, 10, attacker);
					possible_states1.Add(pair.Item1);
					var possible_states2 = neighbor_states2(sup, pair.Item2, 10, attacker2);
					possible_states2.Add(pair.Item2);

					if (possible_states1.Intersect(possible_states2).Count() > 0)
					{

						foreach (var ev in attacker)
						{
							Console.Write(ev.ToString() + " ");
						}
						Console.Write(" and ");
						foreach (var ev in attacker2)
						{
							Console.Write(ev.ToString() + " ");
						}
						//Console.WriteLine();

						Console.WriteLine("- Not P-observable");
					}
					else
					{
						//Console.Write("- OK");
					}
				}
				//Console.WriteLine();
			}
		}
		*/
	}


	return true;


}

Boolean check_Pobservability7(DeterministicFiniteAutomaton H, DeterministicFiniteAutomaton desired_language, List<AbstractEvent> vulnerable_events)
{

	var attack_set = GetAllCombos(vulnerable_events);
	var sup = DeterministicFiniteAutomaton.MonolithicSupervisor(new[] { H }, new[] { desired_language }).SimplifyStatesName();
	//sup.ShowAutomaton("S");
	List<Transition> new_transitions = new List<Transition>();
	foreach (var tr in sup.Transitions)
	{
		if (vulnerable_events.Contains(tr.Trigger))
		{
			new_transitions.Add(tr);
		}
	}

	var nG = new DeterministicFiniteAutomaton(new_transitions, sup.InitialState, "newG");
	nG.ShowAutomaton("nG");

	Dictionary<AbstractState, List<Transition>> transitions_by_destination = nG.Transitions.GroupBy(t => t.Destination)
																		.ToDictionary(xi => xi.Key, xi => xi.ToList());

	Dictionary<AbstractState, List<Transition>> transitions_by_origin = nG.Transitions.GroupBy(t => t.Origin)
																		.ToDictionary(xi => xi.Key, xi => xi.ToList());

	var initial_states = nG.States.Except(transitions_by_destination.Keys);
	Queue<AbstractState> states_to_add = new Queue<UltraDES.AbstractState>();
	List<DeterministicFiniteAutomaton> new_automata = new List<DeterministicFiniteAutomaton>();
	List<Transition> new_tr = new List<Transition>();
	foreach (var ini_sta in initial_states)
	{

		var current_state = ini_sta;
		states_to_add.Enqueue(current_state);
		while (states_to_add.Any())
		{
			current_state = states_to_add.Dequeue();
			if (transitions_by_origin.ContainsKey(current_state))
			{
				foreach (var tr in transitions_by_origin[current_state])
				{
					states_to_add.Enqueue(tr.Destination);
					new_tr.Add(tr);
				}
			}

		}

		new_automata.Add(new DeterministicFiniteAutomaton(new_tr, ini_sta, ini_sta.ToString()));
		new_tr.Clear();
	}

	List<(AbstractState, AbstractState)> ci = new List<(AbstractState, AbstractState)>();
	foreach (var aut in new_automata)
	{
		//aut.ShowAutomaton();
		var ci2 = inconsistent_states2(sup, H, new_automata);
		ci.AddRange(ci2);
	}

	List<List<AbstractEvent>> forbidden_events = new List<List<AbstractEvent>>();
	List<List<AbstractEvent>> forbidden_events2 = new List<List<AbstractEvent>>();

	//var ci = inconsistent_states(sup, H);
	foreach (var pair in ci)
	{
		Console.WriteLine(pair.Item1.ToString() + ", " + pair.Item2.ToString());
	}
	
	var number_of_events = 1;

	while (number_of_events < vulnerable_events.Count())
	{
		foreach (var attacker in attack_set.Where(at => at.Count() == number_of_events).ToList())
		{
			foreach (var ev in attacker)
			{
				Console.Write(ev.ToString() + " ");
			}
			Console.WriteLine();
			/*
			foreach (var fe in forbidden_events2)
			{
				if (attacker.Intersect(fe).Count() == fe.Count())
				{
					Console.Write("- Not P-observable*");
					forbidden_events2.Add(attacker);
					goto teste;
				}

			}
			*/

			foreach (var pair in ci)
			{
				var possible_states1 = neighbor_states3(sup, pair.Item1, 10, attacker);
				possible_states1.Add(pair.Item1);
				var possible_states2 = neighbor_states3(sup, pair.Item2, 10, attacker);
				possible_states2.Add(pair.Item2);
				//Console.Write(pair.Item1.ToString() + ", " + pair.Item2.ToString());

				if (possible_states1.Intersect(possible_states2).Count() > 0)
				{
					//Console.WriteLine("- Not P-observable");
					if (!forbidden_events.Contains(attacker))
					{
						forbidden_events.Add(attacker);
						forbidden_events2.Add(attacker);
					}
				}/*
				else
				{
					Console.WriteLine("- OK");
				}*/
			}
		teste:;
			//Console.WriteLine();

		}
		number_of_events++;
	}

	Console.WriteLine("Eventos proibidos: ");
	foreach (var set in forbidden_events)
	{
		foreach (var ev in set)
		{
			Console.Write(ev.ToString() + " ");
		}
		Console.WriteLine();

		/*
		Console.WriteLine("Testando as novas combinações: ");

		var new_attacker = GetAllCombos(set).Where(at => at.Count() < set.Count());
		foreach (var attacker in new_attacker)
		{

			foreach (var attacker2 in new_attacker)
			{

				foreach (var pair in ci)
				{
					var possible_states1 = neighbor_states2(sup, pair.Item1, 10, attacker);
					possible_states1.Add(pair.Item1);
					var possible_states2 = neighbor_states2(sup, pair.Item2, 10, attacker2);
					possible_states2.Add(pair.Item2);

					if (possible_states1.Intersect(possible_states2).Count() > 0)
					{

						foreach (var ev in attacker)
						{
							Console.Write(ev.ToString() + " ");
						}
						Console.Write(" and ");
						foreach (var ev in attacker2)
						{
							Console.Write(ev.ToString() + " ");
						}
						//Console.WriteLine();

						Console.WriteLine("- Not P-observable");
					}
					else
					{
						//Console.Write("- OK");
					}
				}
				//Console.WriteLine();
			}
		}
		*/
	}


	return true;


}

Boolean check_Pobservability5(DeterministicFiniteAutomaton H, DeterministicFiniteAutomaton desired_language, List<AbstractEvent> vulnerable_events)
{

	var attack_set = GetAllCombos(vulnerable_events);
	var sup = DeterministicFiniteAutomaton.MonolithicSupervisor(new[] { H }, new[] { desired_language }).SimplifyStatesName();
	//sup.ShowAutomaton("S");
	List<List<AbstractEvent>> forbidden_events = new List<List<AbstractEvent>>();
	List<List<AbstractEvent>> forbidden_events2 = new List<List<AbstractEvent>>();

	var ci = inconsistent_states(sup, H);
	var number_of_events = 1;

	while (number_of_events < vulnerable_events.Count())
	{
		foreach (var attacker in attack_set.Where(at => at.Count() == number_of_events).ToList())
		{
			foreach (var ev in attacker)
			{
				Console.Write(ev.ToString() + " ");
			}
			/*
			foreach (var fe in forbidden_events2)
			{
				if (attacker.Intersect(fe).Count() == fe.Count())
				{
					Console.Write("- Not P-observable*");
					forbidden_events2.Add(attacker);
					goto teste;
				}

			}
			*/

			foreach (var pair in ci)
			{
				var possible_states1 = neighbor_states3(sup, pair.Item1, 10, attacker);
				possible_states1.Add(pair.Item1);
				var possible_states2 = neighbor_states3(sup, pair.Item2, 10, attacker);
				possible_states2.Add(pair.Item2);
				Console.Write(pair.Item1.ToString() + ", " + pair.Item2.ToString());

				if (possible_states1.Intersect(possible_states2).Count() > 0)
				{
					Console.WriteLine("- Not P-observable");
					if (!forbidden_events.Contains(attacker))
					{
						forbidden_events.Add(attacker);
						forbidden_events2.Add(attacker);
					}
				}
				else
				{
					Console.WriteLine("- OK");
				}
			}
		teste:;
			Console.WriteLine();

		}
		number_of_events++;
	}

	Console.WriteLine("Eventos proibidos: ");
	foreach (var set in forbidden_events)
	{
		foreach (var ev in set)
		{
			Console.Write(ev.ToString() + " ");
		}
		Console.WriteLine();

		/*
		Console.WriteLine("Testando as novas combinações: ");

		var new_attacker = GetAllCombos(set).Where(at => at.Count() < set.Count());
		foreach (var attacker in new_attacker)
		{

			foreach (var attacker2 in new_attacker)
			{

				foreach (var pair in ci)
				{
					var possible_states1 = neighbor_states2(sup, pair.Item1, 10, attacker);
					possible_states1.Add(pair.Item1);
					var possible_states2 = neighbor_states2(sup, pair.Item2, 10, attacker2);
					possible_states2.Add(pair.Item2);

					if (possible_states1.Intersect(possible_states2).Count() > 0)
					{

						foreach (var ev in attacker)
						{
							Console.Write(ev.ToString() + " ");
						}
						Console.Write(" and ");
						foreach (var ev in attacker2)
						{
							Console.Write(ev.ToString() + " ");
						}
						//Console.WriteLine();

						Console.WriteLine("- Not P-observable");
					}
					else
					{
						//Console.Write("- OK");
					}
				}
				//Console.WriteLine();
			}
		}
		*/
	}


	return true;


}




Boolean check_Pobservability2(DeterministicFiniteAutomaton H, DeterministicFiniteAutomaton desired_language, List<List<Event>> attack_set)
{

	var sup = DeterministicFiniteAutomaton.MonolithicSupervisor(new[] { H }, new[] { desired_language }).SimplifyStatesName();
	//sup.ShowAutomaton("S");


	var ci = inconsistent_states(sup, H);

	foreach (var attacker in attack_set)
	{
		foreach (var ev in attacker)
		{
			Console.Write(ev.ToString() + " ");
		}


		foreach (var pair in ci)
		{
			var possible_states1 = neighbor_states2(sup, pair.Item1, 10, attacker);
			possible_states1.Add(pair.Item1);
			var possible_states2 = neighbor_states2(sup, pair.Item2, 10, attacker);
			possible_states2.Add(pair.Item2);

			if (possible_states1.Intersect(possible_states2).Count() > 0)
			{
				Console.Write("- Not P-observable");
			}
		}
		Console.WriteLine();
	}


	return true;





}

Boolean check_Pobservability(DeterministicFiniteAutomaton H, DeterministicFiniteAutomaton desired_language, List<Event> vulnerable_events)
{

	var sup = DeterministicFiniteAutomaton.MonolithicSupervisor(new[] { H }, new[] { desired_language }).SimplifyStatesName();
	//sup.ShowAutomaton("S");


	var ci = inconsistent_states(sup, H);

	foreach (var ev in vulnerable_events)
	{
		Console.Write(ev.ToString() + " ");
	}

	foreach (var pair in ci)
	{
		var possible_states1 = neighbor_states2(sup, pair.Item1, 10, vulnerable_events);
		possible_states1.Add(pair.Item1);
		var possible_states2 = neighbor_states2(sup, pair.Item2, 10, vulnerable_events);
		possible_states2.Add(pair.Item2);

		if (possible_states1.Intersect(possible_states2).Count() > 0)
		{
			Console.WriteLine("- Not P-observable");
			return false;
		}
	}


	return true;





}


void print_macrostates(List<List<AbstractState>> macro_states)
{

	Console.WriteLine("List of macro states:");
	foreach (var st in macro_states)
	{
		Console.Write("(");
		foreach (var q in st)
		{
			Console.Write(q.ToString() + " ");
		}
		Console.WriteLine(")");
	}
}

/*
List<List<AbstractState>> build_estimator(DeterministicFiniteAutomaton H, List<Event> vulnerable_events)
{

	List<List<AbstractState>> macro_states = new List<List<AbstractState>>();
	List<AbstractState> states = new List<AbstractState>();


	foreach (var st in H.States)
	{
		states = possible_states1(H, st, vulnerable_events);
		macro_states.Add(states);

	}
	return macro_states;
}
*/
List<AbstractEvent> feasible_event(DeterministicFiniteAutomaton H, AbstractState state)
{

	List<AbstractEvent> events = new List<AbstractEvent>();
	foreach (var t in H.Transitions.Where(jj => (jj.Origin == state)))
	{
		events.Add(t.Trigger);
	}
	return events;
}


/*
List<AbstractState> possible_states1(DeterministicFiniteAutomaton H, AbstractState state, List<Event> vulnerable_events)
{
	List<AbstractState> states = new List<AbstractState>();

	states.AddRange(neighbor_states2(H, state, 2, vulnerable_events));
	states.Add(state);

	return states;

}

*/
List<AbstractState> neighbor_states2(DeterministicFiniteAutomaton H, AbstractState state, int n, List<Event> vulnerable_events)
{

	var radius = 1;
	List<Event> manipulated_events = new List<Event>();

	List<AbstractState> visited_states = new List<AbstractState>();
	List<AbstractState> frontier_after = new List<AbstractState>();
	List<AbstractState> frontier_after_aux = new List<AbstractState>();
	List<AbstractState> frontier_before = new List<AbstractState>();
	List<AbstractState> frontier_before_aux = new List<AbstractState>();


	frontier_after.Add(state);
	frontier_before.Add(state);

	while (radius <= n)
	{
		foreach (var s2 in frontier_after)
		{

			foreach (var t in H.Transitions.Where(jj => (jj.Origin == s2)))
			{
				var ev = t.Trigger;
				if (vulnerable_events.Contains(ev))
				{
					visited_states.Add(t.Destination);

					var ns = t.Destination;
					var nt = H.Transitions.Where(jj => (jj.Origin == ns) && (jj.Trigger == ev));
					while (nt.Count() == 1 && !(visited_states.Contains(nt.ElementAt(0).Destination)))
					{
						ns = nt.ElementAt(0).Destination;
						nt = H.Transitions.Where(jj => (jj.Origin == ns) && (jj.Trigger == ev));
						visited_states.Add(ns);
					}
					frontier_after_aux.Add(ns);
				}

			}
		}

		foreach (var s2 in frontier_before)
		{
			foreach (var t in H.Transitions.Where(jj => (jj.Destination == s2)))
			{
				var ev = t.Trigger;
				if (vulnerable_events.Contains(t.Trigger) && !(visited_states.Contains(t.Origin)))
				{
					visited_states.Add(t.Origin);

					var ns = t.Origin;
					var nt = H.Transitions.Where(jj => (jj.Destination == ns) && (jj.Trigger == ev));
					while (nt.Count() == 1 && !(visited_states.Contains(nt.ElementAt(0).Origin)))
					{
						ns = nt.ElementAt(0).Origin;
						nt = H.Transitions.Where(jj => (jj.Destination == ns) && (jj.Trigger == ev));
						visited_states.Add(ns);
					}
					frontier_before_aux.Add(ns);
				}
			}
		}
		frontier_after.Clear();
		frontier_before.Clear();
		frontier_after.AddRange(frontier_after_aux);
		frontier_before.AddRange(frontier_before_aux);
		frontier_after_aux.Clear();
		frontier_before_aux.Clear();


		radius++;
	}
	return visited_states;
}

List<AbstractState> neighbor_states3(DeterministicFiniteAutomaton H, AbstractState state, int n, List<AbstractEvent> vulnerable_events)
{

	var radius = 1;
	List<AbstractEvent> manipulated_events = new List<AbstractEvent>();

	List<AbstractState> visited_states = new List<AbstractState>();
	List<AbstractState> frontier_after = new List<AbstractState>();
	List<AbstractState> frontier_after_aux = new List<AbstractState>();
	List<AbstractState> frontier_before = new List<AbstractState>();
	List<AbstractState> frontier_before_aux = new List<AbstractState>();


	frontier_after.Add(state);
	frontier_before.Add(state);

	while (radius <= n)
	{
		foreach (var s2 in frontier_after)
		{

			foreach (var t in H.Transitions.Where(jj => (jj.Origin == s2)))
			{
				var ev = t.Trigger;
				if (vulnerable_events.Contains(ev))
				{
					visited_states.Add(t.Destination);

					var ns = t.Destination;
					var nt = H.Transitions.Where(jj => (jj.Origin == ns) && (jj.Trigger == ev));
					while (nt.Count() == 1 && !(visited_states.Contains(nt.ElementAt(0).Destination)))
					{
						ns = nt.ElementAt(0).Destination;
						nt = H.Transitions.Where(jj => (jj.Origin == ns) && (jj.Trigger == ev));
						visited_states.Add(ns);
					}
					frontier_after_aux.Add(ns);
				}

			}
		}

		foreach (var s2 in frontier_before)
		{
			foreach (var t in H.Transitions.Where(jj => (jj.Destination == s2)))
			{
				var ev = t.Trigger;
				if (vulnerable_events.Contains(t.Trigger) && !(visited_states.Contains(t.Origin)))
				{
					visited_states.Add(t.Origin);

					var ns = t.Origin;
					var nt = H.Transitions.Where(jj => (jj.Destination == ns) && (jj.Trigger == ev));
					while (nt.Count() == 1 && !(visited_states.Contains(nt.ElementAt(0).Origin)))
					{
						ns = nt.ElementAt(0).Origin;
						nt = H.Transitions.Where(jj => (jj.Destination == ns) && (jj.Trigger == ev));
						visited_states.Add(ns);
					}
					frontier_before_aux.Add(ns);
				}
			}
		}
		frontier_after.Clear();
		frontier_before.Clear();
		frontier_after.AddRange(frontier_after_aux);
		frontier_before.AddRange(frontier_before_aux);
		frontier_after_aux.Clear();
		frontier_before_aux.Clear();


		radius++;
	}
	return visited_states;
}

/*
List<AbstractState> neighbor_states(DeterministicFiniteAutomaton H, AbstractState state, List<Event> vulnerable_events)
{

	List<AbstractState> states = new List<AbstractState>();
	List<AbstractState> visited_states = new List<AbstractState>();



	foreach (var t in H.Transitions.Where(j => (j.Origin == state)))
	{
		var ev = t.Trigger;
		if (vulnerable_events.Contains(ev))
		{
			states.Add(t.Destination);
			visited_states.Add(t.Destination);

			var ns = t.Destination;
			var nt = H.Transitions.Where(j => (j.Origin == ns) && (j.Trigger == ev));
			while (nt.Count() == 1 && !(visited_states.Contains(nt.ElementAt(0).Destination)))
			{
				ns = nt.ElementAt(0).Destination;
				nt = H.Transitions.Where(j => (j.Origin == ns) && (j.Trigger == ev));
				states.Add(ns);
				visited_states.Add(ns);
			}
		}

	}
	foreach (var t in H.Transitions.Where(j => (j.Destination == state)))
	{
		var ev = t.Trigger;
		if (vulnerable_events.Contains(t.Trigger) && !(visited_states.Contains(t.Origin)))
		{
			states.Add(t.Origin);
			visited_states.Add(t.Origin);

			var ns = t.Origin;
			var nt = H.Transitions.Where(j => (j.Destination == ns) && (j.Trigger == ev));
			while (nt.Count() == 1 && !(visited_states.Contains(nt.ElementAt(0).Origin)))
			{
				ns = nt.ElementAt(0).Origin;
				nt = H.Transitions.Where(j => (j.Destination == ns) && (j.Trigger == ev));
				states.Add(ns);
				visited_states.Add(ns);
			}
		}
	}

	return states;

}

*/

//IEnumerable<IGrouping<AbstractState, Transition>> query = from t in G.Transitions
//										 		  group t by t.Origin;

//G.ShowAutomaton();

void pequenaFabrica(out List<DeterministicFiniteAutomaton> p, out List<DeterministicFiniteAutomaton> spec, out List<Event> events)
{
	var st =
		Enumerable.Range(0, 6)
			.Select(ii =>
				new State(ii.ToString(),
					ii == 0
						? Marking.Marked
						: Marking.Unmarked)
			).ToArray();

	int numMaquinas = 3;
	// Creating Events 
	var aa =
		Enumerable.Range(1, numMaquinas)
			.Select(ii =>
				new Event("a" + ii.ToString(), Controllability.Controllable)
			).ToArray();

	var bb =
		Enumerable.Range(1, numMaquinas)
			.Select(ii =>
				new Event("b" + ii.ToString(), Controllability.Uncontrollable)
			).ToArray();



	//----------------------------
	// Plants
	//----------------------------


	var M =
		Enumerable.Range(1, numMaquinas)
			.Select(ii => new DeterministicFiniteAutomaton(
				new[]
				{
							new Transition(st[0], aa[ii-1], st[1]),
							new Transition(st[1], bb[ii-1], st[0])
				},
				st[0], "M" + ii.ToString())
			).ToArray();

	//----------------------------
	// Specifications
	//----------------------------

	var Esp =
		Enumerable.Range(1, numMaquinas - 1)
			.Select(ii => new DeterministicFiniteAutomaton(
				new[]
				{
							new Transition(st[0], bb[ii-1], st[1]),
							new Transition(st[1], aa[ii], st[0])
				},
				st[0], "E" + ii.ToString())
			).ToArray();

	p = M.ToList();
	spec = Esp.ToList();

	events = new List<Event>();
	events.AddRange(aa);
	events.AddRange(bb);

}

void quantEspecification(out DeterministicFiniteAutomaton Q, string evento, int quantidade)
{
	var st =
		Enumerable.Range(0, quantidade + 1)
			.Select(ii =>
				new State(ii.ToString(),
					ii == quantidade
						? Marking.Marked
						: Marking.Unmarked)
			).ToArray();

	var ev = new Event(evento, Controllability.Controllable);

	List<Transition> trans = new List<Transition>();

	for (int ii = 0; ii < quantidade; ii++)
	{
		var t = new Transition(st[ii], ev, st[ii + 1]);
		trans.Add(t);

	}

	Q = new DeterministicFiniteAutomaton(
		trans, st[0], "M1");
}